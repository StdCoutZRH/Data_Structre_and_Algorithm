
## 0.综述
  排序算法对任何一个程序员来说都是一项基本功，在实际的项目中我们也经常需要使用排序。排序算法的选择和使用不仅要针对实际数据的特点，有时候排序的稳定性也必须考虑。这样可以提高程序的运行效率，让开发工作事半功倍。
  
  **学习排序算法不能仅仅停留在了解算法原理和使用代码实现这两步，我们应该在此基础上学会去分析和评价一个算法**。我们可以从以下几各方面去衡量一个排序算法：
  * **对于排序算法执行效率的分析**，包括最好、最坏、平均情况下的时间复杂度，算法运行过程中数据比较和交换的次数等。
  * **对于排序算法的内存消耗分析**。算法的内存消耗通过空间复杂度来衡量。
  * **排序算法的稳定性**。所谓稳定性，就是待排序的序列中的值相同的元素经过排序算法处理后是否保持原先的位置关系，若保持，则称这个排序算法为稳定的排序算法，反之则称为不稳定的排序算法。
## 1.冒泡排序(Bubble sort)
### 1.1冒泡排序算法原理
**冒泡排序算法只操作相邻的两个元素，每次冒泡操作都会比较相邻的两个元素，看着两个元素的大小是否满足要求，要是不满足就交换它们的位置**。每进行一次冒泡就会至少会有一个元素被放到正确的位置上，这样重复n次就可以完成n个元素的排序工作。

例如对于这样一组数据：4,5,6,3,2,1，需要进行从小到大的排序。
**进行第一次冒泡操作的时候**：
* 首先比较4和5，满足条件  此时元素序列为 4,5,6,3,2,1;
* 然后比较5和6，满足条件 此时元素序列为 4,5,6,3,2,1;
* 比较6和3,6比3大，所以交换6和3 此时元素序列为 4,5,3,6,2,1;
* 比较6和2,6比2大，所以交换6和2 此时元素序列为 4,5,3,2,6,1;
* 比较6和1,6比1大，所以交换6和1 此时元素序列为 4,5,3,2,1,6;

这样经过一次冒泡后元素6就被移动到了正确的位置。由于冒泡过程中元素的移动就像气泡网上冒一样，这也是冒泡算法名称的由来。可以看得出，要想对着6个数据进行正确的排序，需要进行6次冒泡操作。


下面是针对上面的数据每一次冒泡后得到的序列状态：
* 初始状态：4,5,6,3,2,1
* 第一次冒泡后：4,5,3,2,1,**6**
* 第二次冒泡后：4,3,2,1,**5**,6
* 第三次冒泡后：3,2,1,**4**,5,6
* 第四次冒泡后：2,1,**3**,4,5,6
* 第五次冒泡后：1,**2**,3,4,5,6
* 第六次冒泡后：**1**,2,3,4,5,6

其中加粗的是每一次冒泡操作往上冒，也就是到达正确位置的元素。

### 1.2冒泡排序算法优化与代码实现
针对上面一节的内容，我们理解了冒泡排序的基本原理与操作步骤。上述的算法是可以优化的，例如针对这样的一组数据：3,4,5,1,2,6。这样的六个数是不是也需要进行六次冒泡操作呢？我们来走一遍冒泡操作看看。
* 初始状态：3,4,5,1,2,6
* 第一次冒泡：3,4,1,2,**5**,6
* 第二次冒泡：3,1,2,**4**,5,6
* 第三次冒泡：1,2,**3**,4,5,6
* 第四次冒泡：1,2,3,4,5,6
* 第五次冒泡：1,2,3,4,5,6

可以看得出来进行到第三次冒泡操作的时候整个序列就已经是有序的了，所以第四次和四五次都没有进行数据交换。有上述分析可知，此处的六个数据只需进行四次冒泡操作就可以了。
实际上当没有数据交换的时候，序列就是完全有序的了，此时我们也可以认为排序已经完成，不用在继续执行后面的冒泡操作了。

最终冒泡排序C语言代码如下：
```c
//a是数组，n是数组中元素的个数
void bubble_sort(int a[],int n)
{
	if(n<=1)
		return;
	for(int i=0;i<n;++i)
	{
		int flag = 0;//设定是否提前退出冒泡排序操作的flag
		for(int j=0;j<n-1;++j)
		{
			if(a[j]>a[j+1])
			{
				int temp = a[j];
				a[j] = a[j+1];
				a[j+1] = temp;
				flag = 1; //flag = 1表示有数据交换
			}					
		}
		if(!flag)
			break;
	}
}
```

### 1.3冒泡排序算法分析
* 由上述分析可以看出，冒泡排序只涉及相邻两个元素的交换操作，它所使用的临时空间是常量级的，所以**冒泡排序算法的空间复杂度为O(1)**，因此它也是一个原地算法（所谓原地算法，就特指空间复杂度为O(1)的算法）。
* 从时间复杂度上看，冒泡排序最好情况是原序列已经有序，这样只需要进行一次冒泡操作即可判断出不需要继续冒泡了，所以最好的情况下时间复杂度为O(n)。而最坏的情况下需要进行n次冒泡操作，每次冒泡又要进行n次比较操作，所以最坏情况复杂度为O(n²）。于是总的时间复杂度为O(n²）。
* 由于可以在程序中设定当两个值相等时不交换两个元素的位置，所以冒泡排序是稳定的排序算法。
## 2.插入排序(Insertion sort)
### 2.1插入排序算法原理

首先思考这样一个问题，如何在一个有序序列中插入一个新元素。假设有需要在这样一个有序序列中插入6：1,7,8,15。很容易想到只需要遍历当前这个有序序列，然后找到应该插入新元素的合适位置插入该元素即可。这是一个动态的插入过程，需要搬移插入位置之后的元素，插入过程如下图：

![在这里插入图片描述](https://img-blog.csdnimg.cn/20190518090603422.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1BlY29IZQ==,size_16,color_FFFFFF,t_70)

由上面的思想就可以引出这部分的主题：插入排序算法。插入排序的算法思想就是：将数组中的数据分为已排序区间和未排序区间两个区间。一开始的时候已排序区间只有一个元素，一般就是数组中的第一个元素。则剩下的数组中的其他元素所组成区间就是未排序区间。插入算法每次选取一个未排序区间内的元素按照上面插入6的方法插入到前面的已排序区间中。一直重复插入操作至未排序区间中的元素个数为0算法结束。


### 2.2插入排序代码实现
与上面的分析不难写出插入排序代码:
```c
void inseration_sort(int a[],int n)
{
	if(n<=1)
		return;
	for(int i=0;i<n;++i)
	{
		int value = a[i];	//待插入的元素
		int j = i-1;	//从后往前找
		//查找插入位置
		for(;j>=0;--j)
		{
			if(a[j]>value)
			{
				a[j+1] = a[j];	//移动数据
			}
			else
				break;
		}
		a[j+1]=value;
	}
}
```

### 2.3插入排序算法分析

* 有上述分析可知，插入排序空间复杂度为O(1),即插入排序算法是一个原地排序算法。
* 在插入排序中我们可以设定对于值相同的两个元素，将后出现的元素插入到前面出现元素的后面，这样就可以保证排序后两个元素的位置关系不变，所以插入排序是一个稳定的排序算法。
* 插入排序的时间复杂度为O(n²)。
## 3.选择排序(Slection sort)
### 3.1选择排序算法原理

选择排序的算法思路有点类似插入排序，它也是分为了已排序区间和未排序区间，并且每次从未排序区间的选取一个元素插入到已排序区间。不同于插入排序的是，选择排序算法每次从未排序区间中找到最小的元素，将其插入到已排序区间的末尾。

### 3.2选择排序代码实现
```c
void slection_sort(int a[],int n)
{
	int temp = 0;
	for(int i=0;i<n-1;++i)
		for(int j=i-1;j<n;++j)
		{
			if(a[i]>a[j])
			{
				temp = a[i];
				a[i]=a[j];
				a[j]=temp;
			}
		}
}
```

选择排序算法实现较为简单，**但是要注意区别，很多人不仔细看会误认为跟冒泡算法实现代码一样。冒泡排序算法是挨个比较两个相邻元素，而选择插入排序是每次将未排序区间内的最小值提取出来插入到已排序区间的末尾**。具体的过程就是挨个比较未排序区间内的元素和已排序区间的末元素，若已排序区间末元素大则替换掉，否则继续比较未排序区间内的下一个元素，直到都比较完。


例如对于下面的序列，第一次选择的时候挨个比较a[0]与后面的元素，10比6大，所以交换它们，序列就成了6,10,7,8,15。注意接下来比较的不是10和7，而是6和7，6和8,6和15！这是和冒泡排序的不同的地方。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20190518094653933.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1BlY29IZQ==,size_16,color_FFFFFF,t_70)

### 3.3选择排序算法分析
* 选择排序的空间复杂度为O(1)，所以它是一个原地排序算法。
* 选择排序不是一个稳定算法，因为选择排序每次从未排序区间中找到一个最小值，并且和前面的元素交换位置，这样就破坏了稳定性。
* 选择排序的时间复杂度为O(n²)。

@[toc](排序算法分析2--归并排序和快速排序)

## 0.综述
在前面一节中，我们分析了**三种时间复杂度为O(n²)的排序算法--冒泡排序、插入排序、选择排序**，由于这三种算法的时间复杂度较高，因而适用于 小规模数据的排序。而今天分析的两种排序算法适用于大规模数据的排序，因为它们的**时间复杂度都是O(nlogn）**。它们分别是**归并排序和快速排序**。

## 1.归并排序(MergeSort)原理
**归并排序利用了分而治之的思想，对于一个未排序的数组，归并排序将它从数组中间分为前后两个部分，然后分别对这两个部分进行排序，再将这两个有序的序列合并起来，最终使整个数组是有序的。**

例如对于包含4,3,2,1,8,76,5这8个元素的序列，我们可以先将其分成4,3,2,1和8,76,5这两组序列，再将它们分为4,3/2,1/8,7/6,5这四组，然后在组内分别排序，得到3,4/1,2/7,8/5,6,然后将它们两两合并，得到1,2,3,4/5,6,7,8,在将这两个合并，最终就得到有序数组：1,2,3,4,5,6,7,8。

整个示意图如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/2019052208525639.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1BlY29IZQ==,size_16,color_FFFFFF,t_70)
分治算法一般用递归来解决，归并排序也是如此。对于递归程序，首先应该弄清楚它的递归边界，也就是终止条件，然后就是它的递归方程。由上面对归并排序的原理分析不难得出，归并排序的递归公式就是：
```c
q = (p+r)/2
merge_sort(p,r)=(merge_sort(p,q),merge_sort(q+1,r)
```
归并排序的递归边界应该就是:
```c
p>=r //p>=r时不再继续分解
```
其中merge_sort(p,r)表示给下标p到下标r直接的元素排序。这样就可以转换成分别给p->q和q+1->r两个区间内的元素进行排序的子问题，其中q是p和r之间中间的元素下标，也就是q=(p+r)/2。

## 2.归并排序代码实现
```c
void merge(int*a,p,q,r)
{
	int *tmp = (int*)malloc((r - p + 1) * sizeof(int));
	if(!tmp)
		perror("malloc failed.")	
	int i, j, k;
	for (i = p, j = q + 1, k = 0; i <= q && j <= r;) 
	{
		if (a[i] <= a[j])
			tmp[k++] = a[i++];
		else
			tmp[k++] = a[j++];
	}
	if (i == q + 1) 
	{
		for (; j <= r;)
			tmp[k++] = a[j++];
	} 
	else {
		for (; i <= q;)
			tmp[k++] = a[i++];
	}
	memcpy(a + p, tmp, (r - p + 1) * sizeof(int));
	free(tmp);	
}

void merge_sort(int *a, int p, int r)
{
	int q;

	if (p >= r)
		return;

	q = (p + r) / 2;
	merge_sort(a, p, q);
	merge_sort(a, q + 1, r);
	merge(a, p, q, r);
}

```
其中merge函数完成的功能是将已经有序的两个序列，也就p->q以及q->r两个序列之间的元素合并到一个序列中。

## 3.归并排序算法分析
* 在归并排序算法中，我们可以设定merge函数中对于值相同的两个元素位置不改变，所以归并排序算法是一个稳定的排序算法。
* 归并排序算法的时间复杂度为O(nlogn)。
* 由于归并排序算法的执行过程中，在合并有序数组的时候需要申请额外的内存空间，所以它不是原地排序算法并且它的空间复杂度为O(n)。

## 4.快速排序(QuickSort)算法原理
快速排序一般被简称为快排，它也用了分治的思想。快排的核心思想是若要对乱序数组中的下标p到r之间的元素排序，我们可以选择p到r之间任意的一个元素作为pivot分区点，将p->r这个序列分为两个部分，我们遍历p->r之间的元素，然后将小于pivot的放在pivot左边，将大于pivot的放在pivot右边，将pivot放在中间。
快排的递推公式如下:
```c
quick_sort(p,r) = quick_sort(p,q-1)+quick_sort(q+1,r)
```
递推终止条件就是：
```c
p>=r
```

## 5.快排代码
```c
void swap(int *a, int *b)
{
	int tmp = *a;
	*a = *b;
	*b = tmp;
}

int get_q(int *a, int p, int r)
{
	int i, j;
	i = j = p;

	for (; j < r; ++j)
	{
		if (a[j] < a[r]) 
		{
			if(i != j)
			{
				swap(a + i, a + j);
			}
			++i;
		}
	}
	swap(a + i, a + r);
	return i;
}

void quick_sort(int *a, int p, int r)
{
	int q;
	if (p >= r)
		return;
	q = get_q(a, p, r);
	quick_sort(a, p, q-1);
	quick_sort(a, q+1, r);
}
```
## 6.快排分析
* 快排是一个不稳定的排序算法，但是它是原地的排序算法。
* 快排的时间复杂度为O(nlogn)。