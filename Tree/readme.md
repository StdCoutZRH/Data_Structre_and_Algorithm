# 数据结构之树的基本概念

## 1树的定义
树是一种**非线性**的数据结构，它是若干节点的集合，是由唯一的根和若干个不相交的子树组成的，其中每一棵子树又是一棵树。由此可知，树是可以递归定义的，即在树的定义中又用到了树的定义。需要注意有一个特殊情况，就是树的节点可以为零，这个时候的树就是一棵空树。

如下图：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20191002185145982.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1BlY29IZQ==,size_16,color_FFFFFF,t_70)
其中A节点就是根节点，而B、E、K、F、L等节点组成的树就是一棵子树。

## 2树的基本术语

以上图的树为例：
* 结点：A,B,C,D,E...等都是树的结点，结点不仅包含数据元素，同时也包含指向子树的分支。比如对于根节点A，它有三个子树，所以除了数据元素A，它也包含着三个指向每个子树的指针。
* 结点的度：结点有几个子树它的度就是几。例如A有三个子树，所以A的度就是3。
* 树的度：树中每个结点的度的最大值就是这个树的度。例如上面的树中，A,D有三个子树，这是最多的，所以这个树的度就是3。
* 叶子结点：也叫作终端节点，指度为0，也就是下面没有分支、子树的结点。如F,G,I,J,K,L,M都是叶子结点。
* 非终端结点：也叫分支结点，指度不为0的结点，也就是下面有分支，子树的结点。
* 孩子：结点子树的根，如A的孩子为B,C,D。
* 双亲：与孩子的定义对应，如B、C、D结点的双亲都是A.
* 兄弟：同一个双亲的孩子之间互为兄弟。如B、C、D互为兄弟，因为它们都是A结点的孩子。
* 祖先：从根到某结点的路径上的所有结点，都是这个结点的祖先。如K的祖先是A、B、E,因为从A到K的路径为A->B->E->K。
* 子孙：以某结点为根的子树中的所有结点，都是该结点的子孙。如D的子孙为H、I、J M。
* 层次:从根开始，根为第一层，根的孩子为第二层，根的孩子的孩子为第三层，以此类推。
* 树的高度(或者深度):树中结点的最大层次。如例子中的树共有4层，所以高度为4。
* 结点的深度和高度：
1.结点的深度是从根结到该结点路径上的结点个数。
2.从某结点往下走可能到达多个叶子结点，对应了多条通往这些叶子结点的路径，其中最长的那条路径的长度即为该结点在树中的高度，如结点D的高度为3，就是从D到M的路径长度。
3.根结点的高度为树的高度，如结点A,其高度为4,是从A到K (L、M)这条路径的长度，也是整棵树的高度。
* 堂兄弟：双亲在同一层的结点互为堂兄弟。如G和H互为堂兄弟，因为G的双亲是C,H的双亲是D, C和D在同一层上。注意和兄弟的概念的区分。
* 有序树：树中结点的子树从左到右是有次序的，不能交换，这样的树叫作有序树。
* 无序树:树中结点的子树没有顺序，可以任意交换，这样的树叫作无序树。
* 丰满树:丰满树即理想平衡树，要求除最底层外，其他层都是满的。
* 森林：若干棵互不相交的树的集合。例子中如果把根A去掉，剩下的3棵子树互不相交，它们组成一个森林。

## 3树的存储结构
### 3.1顺序存储结构
树的顺序存储结构最直观的是双亲存储结构，用一位数组即可以实现。定义方法就为：
```c
int tree[maxSize];
```

下面来举一个例子说明一个数组是如何表示一棵树的。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20191002191710417.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1BlY29IZQ==,size_16,color_FFFFFF,t_70)
如上图，用数组下标表示树中的结点，数组元素的内容就表示该节点的双亲结点，这样有了结点（下标）以及结点直接的关系（内容），就可以表示一棵树了。比如下标5的内容为3，说明节点5的双亲结点为3；下标1处的结点内容为-1，说明1为根节点。

用这种存储结构来存储树，当知道一个结点后就可以很容易的找到其双亲结点。即已知结点i，那么它的双亲结点就是tree[i]，因此这样的存储方式称为双亲存储结构。

说明:
>* 这里介绍的双亲存储结构是一种高度简化的形式，实际应用中一般不会仅是一个整型树组这么简单，可能是一个复杂的结构体数组，结构体内包含了实现实际用途所需要的信息。
>* 树的双亲存储结构在克善斯卡尔算法中有重要应用。

### 3.2树的链式存储结构
树的链式存储结构最常用的有以下两种:
(1)孩子存储结构 
孩子存储结构实质上就是图的邻接表存储结构。树就是一种特殊的图，把图中的多对多关系删减为一对多关系即得到树，因此图的存储结构完全可以用来存储树。
(2)孩子兄弟存储结构G
孩子兄弟存储结构与树和森林与二叉树的相互转换关系密切，因此放在树和森林与二叉树的相互转换这一节讲解。

说明:这里讲到的树的双亲存储结构、孩子存储结构和孩子兄弟存储结构在不同的学校试卷中可能出现不同的表述，最严格的表述应该是:
* 树的顺序存储结构的双亲表示法;
* 树的链式存储结构的孩子表示法或孩子兄弟表示法。

@[toc](数据结构之二叉树)

## 1.二叉树的定义
在理解了树之后，再来看二叉树就很容易理解了。二叉树就是在一般的树上增加了如下两个限制条件：
* **1.树中的每个结点至多有两棵子树，也就是说树中的结点的度只能为0,1，2**。
* **2.结点的子树有左右之分，不可以颠倒顺序**。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191002202500683.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1BlY29IZQ==,size_16,color_FFFFFF,t_70)
根据上面的定义，可以看出二叉树共有5中基本形态（如上图），即空二叉树、只有一个根结点的二叉树、只有左子树的二叉树、只有右子树的二叉树以及左右子树都有的二叉树。

在一棵二叉树中，如果所有的分支结点都有左孩子和右孩子结点，并且叶子结点都集中在二叉树的最下面一层，那么就成这样的二叉树为**满二叉树**。

如果对一棵深度为k，有n个结点的二叉树进行编号后，各个结点的编号与深度为k的满二叉树中相同位置上的结点的编号均为相同，那么就称这样的二叉树为**完全二叉树**。

通俗的说，一棵完全二叉树一定是由一个满二叉树从右至左从下至上，挨个删除结点所得到的。如果跳着删除，那么得到的就不是完全二叉树。

## 2.二叉树的主要特征
>* 性质1：**非空二叉树上叶子结点数等于双分支结点数加1**。
>* 性质2：**二叉树的第i层上最多有$2^{i-1}(i>=1)$个结点**。
>* 性质3：**高度（或深度）为k的二叉树最多有$2^{k-1}(k>=1)$个结点，也就是说，满二叉树的前k层结点总数为$2^{k-1}$**。
>* 性质4：**给定n个结点，可以构成$\frac{C^n_{2n}} {n+1}$种不同的二叉树**。
>* 性质5：**具有n个结点的完全二叉树的高度为$\lfloor log2^n\rfloor+1$**。
## 3.二叉树的顺序存储结构和链式存储结构
### 3.1顺序存储结构
顺序存储结构使用一个数组来存储一棵二叉树，这种存储方式最适合完全二叉树，但用于存储一般二叉树会浪费大量的存储空间。将完全二叉树的结点值按编号依次存入一个一位数组中，即完成了一个二叉树的顺序存储。

### 3.2链式存储结构
顺序存储显然有很大的局限性，不便于存储任意形态的二叉树。观察二叉树可以发现二叉树是一个根节点与两棵子树之间的关系，因此设计出一种含有一个数据与和两个指针域的链式结构，具体如下：
```c
typedef struct BTNode
{
	char data;
	struct BTNode* lchild;
	struct BTNode* rchild;
}BTNode;
```
## 4.二叉树的遍历
二叉树的遍历方式有先序遍历、中序遍历、后序遍历和层次遍历。

### 4.1 先序遍历：根左右
```c
void preorder(BTNode* p)
{
	if(p!=NULL)
	{
		visit(p);
		preorder(p->lchild);
		preorder(p->rchild);
	}
}
```

### 4.2 中序遍历：左根右
```c
void inorder(BTNode* p)
{
	if(p!=NULL)
	{
		preorder(p->lchild);
		visit(p);
		preorder(p->rchild);
	}
}
```

### 4.3 后序遍历：左右根
```c
void postorder(BTNode* p)
{
	if(p!=NULL)
	{		
		preorder(p->lchild);
		preorder(p->rchild);
		visit(p);
	}
}
```

**练习题：**
1.写一个算法求一棵二叉树的深度，二叉树以二叉链表为存储方式。
```c
int getDepth(BTNode*p)
```
2.在一颗以二叉链表为存储结构的二叉树中，查找data域等于key的结点是否存在，若存在找到任何一个满足要求的结点即可，并将q指向该节点，否则将q赋值为NULL，设data为int型。（剪枝的概念）
```c
void search(BTNode* p,BTNode*&q,int key)
```
3.假设二叉树采用二叉链表存储结构进行存储，设计一个算法输出先序遍历中第k个结点的值，设k不大于总的结点数，且data为char型。
```c
void trave(BTNode*p,int k)
```

### 4.4 层次遍历
```c
void level(BTNode*p)
{
	int front,rear;
	BTNode* que[maxSize];
	front=rear=0;
	BTNode*q;
	if(p!=NULL)
	{
		rear=(rear+1)%maxSize;
		q=que[front];
		visit(q);
		if(q->lchild!=NULL)
		{
			rear=(rear+1)%maxSize;
			que[rear]=q->lchild;
		}
		if(q->rchild!=NULL)
		{
			rear=(rear+1)%maxSize;
			que[rear]=q->rchild;
		}
	}
}
```
**练习题**：
1.假设一个二叉树采用二叉链表存储结构存储，设计一个算法求出该二叉树的宽度。

## 5.二叉树深度优先遍历算法的非递归实现
先序遍历非递归算法：
```c
void preorderNorecu(BTNode* bt)
{
	if(bt!=NULL)
	{
		BTNode* Stack[maxSize];//定义一个栈
		int top = -1;//初始化这个栈
		BTNode* p;
		Stack[++top]=bt;//根结点入栈
		while(top!=-1)
		{
			p=Stack[top--];//出栈并输出栈顶结点
			visit(p);//访问结点p
			if(p->rchild!=NULL)//栈顶结点的右孩子存在则右孩子入栈
			{
				Stack[++top]=p->rcild;
			}
			if(p->lchild!=NULL)//栈顶结点的左孩子存在则左孩子进栈
			{
				Steck[++top]=p->lchild;
			}
		}
	}
}
```

中序遍历非递归算法实现：
```c
void inorderNorecu(BTNode* bt)
{
	if(bt!=NULL)
	{
		BTNode* Stack[maxSize];//定义一个栈
		int top = -1;//初始化这个栈
		BTNode* p;
		p = bt;
		
		while(top!=-1||p!=NULL)
		{
			while(p!=NULL)	//左孩子存在则左孩子进栈
			{
				Stack[++top]=p;
				p=p->lchild;
			}
			if(top==-1)//在栈不为空的情况下出栈并输出栈结点
			{
				p=Stack[top--];
				visit(p);
				p=p->rchild;
			}
		}
	}
}
```

后序遍历算法的非递归实现：
```c
void inorderNorecu(BTNode* bt)
{
	if(bt!=NULL)
	{
		//定义两个栈
		BTNode* Stack1[maxSize];int top1 = -1;
		BTNode* Stack2[maxSize];int top2 = -1;
		BTNode* p = NULL;
		Stack1[++top1] = bt;
		
		while(top1!=-1)
		{
			p = Stack1[top1--];
			Stack2[++top2]=p;
			if(p->lchild!=NULL)
				Stack1[++top1]=p->lchild;
			if(p->rchild!=NULL)
				Stack1[++top1]=p->rchild;
		}
		while(top2!=-1)
		{
			p = Stack2[top2--];//出栈序列即为后序遍历序列
			visit(p);
		}
	}
}
```





